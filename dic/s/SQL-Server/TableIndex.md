# Table Index

インデックスの「直接フィールド」と「`INCLUDE`フィールド」を分けることで、主に以下の点でパフォーマンスや設計上の違いが生じます：

---

### 1. **インデックスの構造とパフォーマンス**
#### 直接フィールド（インデックスキー列）
- **役割**: インデックスの検索キーとして使用されます。これらの列は、ソートされた構造（Bツリー）内に格納されます。
- **影響**:
  - **検索効率**: ソートされているため、検索やフィルタリングに最適です（`WHERE`句や`JOIN`条件で使用される場合）。
  - **サイズ増加**: ソートされて格納されるため、キー列が多いほどインデックスのサイズが大きくなり、メモリやストレージの消費が増加します。
  - **更新コスト**: キー列が変更されると、インデックス全体の再構築が必要になるため、`INSERT`, `UPDATE`, `DELETE`のパフォーマンスに影響を与えます。

#### INCLUDEフィールド（非キー列）
- **役割**: 主にクエリのカバリング（テーブルアクセスを省略する）を目的に、インデックスに格納されるが、ソートには使用されません。
- **影響**:
  - **検索効率**: ソートされないため、検索条件や結合条件に適していません。ただし、結果セットに含める列として効率的に利用できます。
  - **サイズ削減**: INCLUDE列はソートされないため、キー列に比べてインデックスのサイズ増加が抑えられます。
  - **更新コストの軽減**: ソートやキーの再構築が不要なため、INSERTやUPDATEのコストに与える影響が少ないです。

---

### 2. **クエリの用途に応じた設計**
- **直接フィールドを多用する場合**:
  - 適用するクエリ:
    ```sql
    SELECT product_id
    FROM dbo.table1
    WHERE draft_flag = 1 AND description_existence = 1 AND recommend = 1;
    ```
    - `draft_flag`, `description_existence`, `recommend`はフィルタリング条件として使用されるため、キー列に適しています。
    - クエリの実行では、ソート済みのインデックスを効率的に検索できます。

- **INCLUDEフィールドを活用する場合**:
  - 適用するクエリ:
    ```sql
    SELECT product_id, at_member_id
    FROM dbo.table1
    WHERE draft_flag = 1;
    ```
    - `draft_flag`はフィルタリング条件であるため、キー列に適しています。
    - `product_id`, `at_member_id`は結果セットに必要な列として利用されるだけなので、`INCLUDE`で十分です。
    - INCLUDEを使うことで、テーブルアクセスを省略しつつ、インデックスのサイズ増加を抑えます。

---

### 3. **パフォーマンスの違い**
#### キー列にすべてを指定した場合:
- **メリット**:
  - 検索やフィルタリングで最大のパフォーマンスを発揮。
- **デメリット**:
  - インデックスのサイズが大きくなり、更新のオーバーヘッドが増加。

#### INCLUDE列を使った場合:
- **メリット**:
  - インデックスのサイズを抑え、更新コストを軽減。
  - クエリのカバリング（インデックスだけでデータ取得）が可能。
- **デメリット**:
  - INCLUDE列はソートされないため、検索や結合条件には適さない。

---

### 4. **設計のベストプラクティス**
- フィルタリング条件 (`WHERE`, `JOIN`, `GROUP BY`) に使用される列は**インデックスキー列**にする。
- 結果セットの取得にのみ必要な列（`SELECT`句で返される列）は**INCLUDE列**にする。
- 頻繁に更新される列やサイズの大きい列は**INCLUDE**にしない。

---

### 具体例の設計比較
1. **すべてキー列に指定した場合**:
   ```sql
   CREATE NONCLUSTERED INDEX [index_full_key]
   ON [dbo].[table1] ([draft_flag], [description_existence], [recommend], [product_id], [at_member_id]);
   ```
   - サイズが大きくなり、更新コストが高い。

2. **INCLUDEを使用した場合**:
   ```sql
   CREATE NONCLUSTERED INDEX [index_with_include]
   ON [dbo].[table1] ([draft_flag], [description_existence], [recommend])
   INCLUDE ([product_id], [at_member_id]);
   ```
   - 必要な条件を満たしつつ、インデックスのサイズと更新コストを抑える。

クエリの実行頻度やパフォーマンス要件に応じて、バランスよく設計してください！
