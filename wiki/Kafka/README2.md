# Kafka

https://kafka.apache.org/documentation/  
https://epicdevs.com/17  

## Introduce
링크드 인에서 개발된 분산 메시징 시스템으로 대용량의 실시간 로그처리에 특화된 아키텍쳐

지금도, 앞으로도 시스템은 점점 커져가고 있음

이로 인해 시스템 복잡도가 증가하게 되고 이에 따라 운영 업무에 시간이 많이 필요하게 되며 장애 발생은 예외 상황이 아닌 당연히 일어날 수 밖에 없게 되므로 복구 시간도 많이 필요하게 됨

각각의 전송 영역을 하나의 통합된 전송 영역으로 바꾸어 성능과 시간을 개선하기 위한 방법

## Structure
1. 메시지를 특정 수신자에게 직접 보내는 방식이 아님
    * 데이터 생산(Producer)과 데이터 소비(Consumer)가 서로 독립적인 관계임
      >Producer는 메시지 생산(Push)만 하고 Consumer는 메시지를 가져와서(Pull) 처리만 하므로 Consumer는 최적의 성능을 낼 수 있음
    * 메시지 처리가 Pull이므로 Batch처럼 사용할 수도 있음
2. 메시지를 메모리 큐에 적재하는게 아닌 디스크에 순차적으로 저장함
    * 장애가 발생해도 데이터 유실 가능성이 없음
    * 디스크 IO가 줄고 성능이 올라감
    * 처리되지 않은 메시지가 많아도 성능 감소가 없음
    * 처리된 메시지를 일정 기간 동안 삭제하지 않기 때문에 문제가 발생해도 재처리가 가능
3. 분산, 복제 구성이 용이함
4. TCP기반의 프로토콜로 인해 오버헤드가 높지 않음


## Topic, Partition
1. Producer는 Topic의 메시지를 생성하고 Broker에 전달
2. Broker가 받은 메시지를 Topic별로 분류, 관리
3. Consumer가 필요한 Topic의 메시지를 가져가서 처리

대략적인 구조는 이러함

Topic은 파티션 단위로 나뉘어 클러스터의 각 서버에 분산돼 저장

리플리케이션 설정이 되어있다면 파티션 단위로 각 서버에 분산돼 복제되고 장애 발생 시 파티션 단위로 Fail Over가 수행

각 파티션은 0부터 1씩 증가하는 오프셋 값을 메시지에 매칭하므로 파티션 번호와 오프셋으로 메시지를 식별

* 파티션 분산

  메시지를 전달할 때 어떤 파티션으로 전송할 지는 사용자가 지정한다
  >균등히 분배해 저장한다던지, 알파벳으로 시작하는 메시지는 한 파티션에만 저장하고 나머지 메시지는 다른 파티션에 저장한다던지

* 파티션 복제

  파티션을 복제하고 클러스터에 분산시킬 수 있음

  각 파티션에 대한 읽기, 쓰기 작업은 Leader에서 담당하고 Follower는 Leader 복제만 함

  그러다 Leader에 문제가 발생하면 Follower 중 하나가 Leader가 됨

  하나의 Leader가 읽기, 쓰기를 같이 해도 Broker에서 Leader를 분산시켜 놓기 때문에 부 하가 높지 않음

## Consumer, Consumer Group




## File System
메시지를 메모리가 아닌 디스크에 저장하기 때문에 메시지가 JVM 객체로 변환되며 크기가 커지는 것을 방지하고 가비지컬렉터로 인한 성능 저하도 방지

하드디스크의 순차적 읽기 속도는 메모리 랜덤 읽기 속도보다 빠를 정도로 높기 때문에 하드디스크를 사용하더라도 성능 유지가 됨

또한 관리를 OS에 위임하기 때문에 캐시를 효과적으로 사용가능

네트워크 전송 시에 zero-copy 방법을 사용하기 떄문에 데이터 전송 성능이 좋음

