【【始めに
前回紹介した方法は、管理者権限ユーザーの資格情報が利用者側に必要でした。
今回はタスクスケジューラのイベントトリガーを使用して、特権が必要な操作を任意のユーザーから実行させる方法を紹介します。なおイベントログとタスクスケジューラによる委任なので、PowerShell以外でも応用可能です。

サンプル
本コラムのサンプルスクリプトはこちらからダウンロードできます。使用する場合はC:¥Temp 直下に展開してください。
（サンプルスクリプト）

設定から実行までの流れ
今回は以下のステップで進めていきましょう。
(画像)

実行対象と配置先を決める
ここでいう実行対象は、スクリプトや実行ファイルなどです。
実行対象は、実行を依頼したユーザーとは別のユーザーのコンテキストで実行されるため、入力待ちが起こらないようする必要があります。
”配置先や実行対象は、管理者のみ参照・実行権限のあるようにしましょう。”さもないと、一般ユーザーが書き換えや差し替えをするだけで任意のコマンドやプログラムを実行できてしまいます。

イベントとタスクのパラメータを決める

トリガーとなるイベントに必要なパラメータ
イベントログの作成にNew-EventLog、出力のためにWrite-Eventlog コマンドレットを使用します。
タスクのイベントトリガーには「ログ」「ソース」「イベントID」が必要です。重複すると意図しないタイミングで発動してしまうので注意して設計しましょう。
今回使用するパラメータは以下の通りです。
（画像）

イベントは3種類用意しています。トリガーに一つ、結果に二つ使用しています。
イベントトリガーは実行が保証されません。正否がユーザーにわかるように通知する仕組みを入れるとよいでしょう。

タスクスケジューラ
タスクスケジューラで設定する項目は以下の通りです。
（画像）

イベントソースを作成する
「管理者として実行」で起動してイベントソースを作成します。
作成には New-EventLog、削除はRemove-EventLogコマンドレットを使用します。

CreateEventSource.ps1
（画像）

実行対象を配置する

決めた配置先にスクリプトを配置します。本番環境であれば、アクセス権の設定と確認も忘れずに。
今回はこちらのサンプルを用意しました。管理者権限が必要なセキュリティログを取得し、C:\Temp\SecurityLog.csv に出力します。サンプルなのでスクリプトも同じC:¥Temp に配置しています。
なおPowerShellのコンソールから直接このサンプルを実行する場合、[System.Environment]::Exit()の部分でPowerShellが終了してしまうので、試しに実行したい場合はコメントアウトしたり Return で置き換えてください。

C:\Temp\OutputSecurityLogs.ps1
（画像２）

タスクを作成する
複数台に展開するのであれば、タスクスケジューラのGUIで作成後にエクスポートします。今回はこの方法についても軽く触れます。
まずはGUIでの設定から。

GUIでタスク作成
全般タブの「タスクの実行時に使うユーザーアカウント」は SYSTEM とするのが一番単純なので、今回はこれを採用しています。
（画像）

もし特定のユーザーを指定する場合はパスワードの記録が必要となります。一方、エクスポートしたXMLにはパスワードは含まれません。インポートやそれを確定するときに必要になります。
「トリガー」には、ユーザーに発行させるイベントの情報を設定します。
（画像）

「操作」は実行対象を指定します。今回はPowerShell.exeとスクリプトファイルです。引数の方に実行対象となるスクリプトを指定します。
（画像）

タスクの「条件」タブですが、特に重たい処理をするのでなければ「電源」の項目のチェックを外しておくとよいでしょう。
在宅だとケーブルが抜けていたり、本体に差しているType-Cケーブルが正規の電源につながっていないために電流が足りなかったりといった状態はよくあります。
（画像）

最後にOKを押せば確定。個別のユーザーを実行アカウントに指定していた場合はパスワードの入力が求められます。

タスクXMLのエクスポート
出来上がったタスクをエクスポートします。一台だけで使用するならこの手順は不要です。
（画像）

XMLの編集
その後、必要に応じて保存されたXMLを編集します。
作成者をユーザー名にしたくないなら「Author」を修正。ユーザーを個別で指定した場合SIDが使用されますが、ローカルアカウントの場合これが端末ごとに不一致になるので「UserId」をユーザー名に修正したりします。保存の際にUTF-16とするのを忘れずに。今回はビルトインアカウント「SYSTEM」を使うのでSIDのままでもよいでしょう。
（画像）

タスクXMLのインポート

タスクスケジューラのGUIを使用してXMLをインポートする場合は右ペインの「タスクのインポート」でインポートします。「タスクXMLに、書式設定が正しくない値または範囲外の値が含まれています。」というエラーが出る場合は「ユーザーまたはグループの変更」で同じユーザーアカウントを指定します。今回はOutputSecurityLogs.xmlを指定します。
（画像）

PowerShellであれば以下のように登録します。今回のようにSYSTEMアカウントなどパスワード不要な場合、UserとPasswordの指定は不要です。フォルダ配下なら TaskPath パラメータを追加してください。

RegisterTask.ps1
（画像）

ユーザーから実行する

イベントログに書き込む
標準ユーザーからイベントログを書き出します。PowerShellを開いて以下のように発行します。
（画像）

その後イベントログが出ているか確認しましょう。ログはGet-EventLogまたはGet-WinEventで取得できます。
（画像）

Get-EventLog と Get-WinEvent はオプションや扱えるイベントログの種類などが違います。evtxファイルとなっているログを扱えるかどうかや検索条件などの違いもあるので、適したものを選択してください。

さて。うまくいけば、ID(Get-WinEventの場合は InstanceId)が1001のログが見つかります。メッセージに書かれたCSVを開けば、システムアカウントで実行された結果の書かれたCSVが確認できるはずです。
（画像）

ところでエンドユーザーにPowerShellを操作してもらうのは大変なので、ダブルクリックで動くバッチをTIPSとサンプルとして作成しました。サンプルの GetSecurityLogs.bat を実行すると、イベントログを発行してタスクの完了を待ち、結果を表示します。

終わりに
タスクスケジューラを使用して、標準アカウントから管理者の処理を実行する方法を紹介しました。
シンクライアント端末のように、ユーザーは管理者権限を持たせないという設計はよくあるのですが、実際運用してみると「この機能のためだけに管理者権限が欲しい」「UACの画面が邪魔」とったことがあります。
そんな時、管理者権限を一律付与したりUACを無効にする前に、こんな手法も検討してみてはいかがでしょうか。
昨今は標準ユーザーではなく、管理者権限を付与した状態でサードパーティーで監視するというケースが多々あることかと思いますが、今回紹介する方法はスタンドアロンかつWindows標準の機能で実現できます。
ちなみに私は、WORKGROUP環境のシンクライアント端末のトラブルシュートを、エンドユーザーで実行する仕組みに使ったりしました。
参考になれば幸いです。

TIPSなど
解説のテンポが悪くなりそうなTIPSなどをまとめました。

PowerShellを用いたタスクのエクスポート
もしたくさんのタスクを作ったのなら、スクリプトでまとめてエクスポートした方が楽でしょう。Get-ScheduledTask と Export-ScheduledTask コマンドを使用してXMLのテキストを取得し、それをUTF-16で保存します。
以下はタスク名に「Update」を含むタスクをXMLで保存する例です。
（スクロール画像）

バッチファイルにPowerShellを組み込んだサンプル
PowerShellだとダブルクリックで開くといったことはできず、ExecutionPolicyの設定などちょっと煩雑。そこで、PowerShellのコードをバッチファイルに埋め込んでしまおう…そんなサンプルです。サンプルコードの GetSecurityLogs.bat を実行するとイベントログを発行してタスクの完了を待ち、結果を表示します。
バッチファイルにPowerShellのコードを書き込むテクニックについては様々な人が研究しているようです。皆さんそれぞれ特徴があるので、見ていて興味深いものがあります。
バッチファイルは、エンコードをDefault(日本語版環境ならSJIS)にする必要があるのでその点は要注意です。

GetSecurityLogs.bat
（スクロール画像）

※文章中の商品名、会社名、団体名は、各社の商標または登録商標です。
